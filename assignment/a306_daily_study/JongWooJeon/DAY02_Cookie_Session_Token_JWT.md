### 개요

---

- 반복되는 작업은 줄일수록 좋다. 예를 들어, 자주 사용하는 웹사이트에 들어갈 때마다 매번 로그인해야 한다면 웹사이트를 이용하는 것이 불편할 것이다.
- 그렇기 때문에 이러한 정보는 `한 번 작성하거나 사용한 뒤`에는 `반복적으로 작업하지 않도록 저장`해 둘 필요가 있다.
- 웹 환경에서는 이처럼 `반복적으로 사용되는 데이터나 정보를 종류와 특성에 맞게 저장하고 재활용`하기 위해 여러 방식을 사용하는데 그 중에서도 `쿠키`, `세션`, `토큰`에 대해 알아보자!

### 쿠키(Cookie)

---

- 크롬이나 사파리 같은 `브라우저에 저장`되는 작은 텍스트 조각이다.
- 브라우저는 사용자의 컴퓨터에 설치된 소프트웨어이므로 쿠키는 사용자가 갖고 있는 정보라고 할 수 있다.
- 사용자는 브라우저의 설정 화면이나 개발자 도구에서 쿠키를 확인하고 직접 수정, 삭제 할 수 있다. 다만 쿠키는 `당사자 뿐만 아니라 제 3자가 조회하는 것도 가능`하기 때문에 개인 정보를 담은 내용이나 `보안 상 민감한 정보를 저장하는 데에는 적합하지 않다.`
- 쿠키를 활용하여 장바구니에 물건을 담아두거나 검색 기록에서 이전에 입력했던 검색어들을 찾아 볼 수 있다.

### 세션(Session)

---

- 웹사이트에 아이디와 비밀번호를 입력해 로그인하면 해당 사이트의 회원에게만 허용된 기능을 사용할 수 있다. 이때 클릭 하나하나는 매번 서버에게 `새로 보내는 익명 편지`와도 같아서 `로그인을 하는 등의 이전 행동들과 연결되어 있지 않다.`
- 다시 말해 서버는 아이디와 비밀번호를 입력해 `로그인에 성공한 사용자`와 로그인한 다음 `마이페이지 버튼을 누른 사용자`가 `동일 인물임을 알 수 없다!!`
    
    ![image](https://github.com/user-attachments/assets/5d365735-7267-4993-9757-2da7724358af)
    
- 따라서 사용자가 사이트에 `로그인한 상태라는 점을 서버에서 인증`하지 못하면 클릭할 때마다 반복해서 아이디와 비밀번호를 서버에 제공해야 한다.
- 이런 번거로움을 해결하기 위해 사용하는 것이 바로 `세션`이다.
- `세션`은 사용자가 사이트에 `한 번 로그인하면 유효 기간이 끝날 때까지` 더이상 아이디와 비밀번호를 입력하지 않아도 되도록 `사용자가 이미 서버로부터 인증받았음을 증명`해 주는 `증서`로 사용된다.
- 로그인 성공 시 사용자는 `서버`로부터 받은 `세션 아이디`를 `쿠키`로 저장한 다음 `앞으로의 모든 요청에 함께 전달`한다.
    
    ![image 1](https://github.com/user-attachments/assets/519a889c-1626-4600-bfb4-6c0badda6952)
    
- 친구 목록을 볼 때, 댓글을 작성하거나 삭제할 때, 구매한 상품 내역을 볼 때도 `서버에게 세션 아이디를 적은 편지를 보낸다.`
- 서버는 사용자에게서 친구 목록을 보겠다는 요청을 받으면 그 편지에 세션 아이디가 적혀있는지를 확인하여 만약 서버가 보관하고 있는 세션 아이디와 동일하다면 누구인지 파악한 다음 해당 사용자의 친구 목록을 보내준다.
- 즉, 세션은 `로그인 여부` 등 `사용자`와 `서버`의 관계가 `기억되어 보존되고 있는 상태`를 말한다.

### 토큰(Token)

---

- `세션` 방식은 `안전하고 효과적`이지만 단점도 있다. 서버는 요청마다 함께 딸려오는 세션 아이디를 바로바로 확인할 수 있도록 로그인 한 아이디를 `메모리`라는 책상에 올려둔다.
- `메모리에 올려둔 데이터를 빠르게 확인`할 수 있다는 장점이 있는 대신 `공간이 한정`되어 있다.
- `서버에 동시 접속`하는 사용자가 많아지면 `메모리 공간이 부족`해져서 서버에 부하가 걸리고 화면이 움직이지 않는 등의 문제가 발생할 수 있다.
- 메모리 공간을 많이 차지하는 세션 방식의 대안은 로그인 한 사용자에게 세션 아이디 대신 `토큰`을 발급해주는 것이다. 이러한 `토큰`에는 특수한 수학적 원리가 적용되어 있어서 마치 위조 방지 장치가 있는 지폐처럼 `서버만이 유효한 토큰을 발행`할 수 있다.
    
    ![image 2](https://github.com/user-attachments/assets/e526218d-815d-447e-a274-3b960dccc9b3)
    
- 토큰을 받아간 사용자가 이를 `쿠키`로 저장해 두고 `필요할 때마다 제시`하면 `서버`는 따로 책상에 올려놓은 것을 확인할 필요 없이 `자기가 발급한 토큰임을 알아보고 사용자의 요청을 허가`해 주는 것이다.
- 더이상 이미 로그인한 사용자의 티켓을 책상(메모리)에 올려 두고 있을 필요가 없으니 `서버 부하`를 줄일 수 있다.
- 물론 토큰 방식에도 `한계`가 존재하는데, `여러 기기에서 로그인을 제한하기 위해 필요한 때에 로그인되어 있는 사용자를 서버가 강제로 로그아웃을 시킬 수 있어야 하는데 토큰 방식에서는 이것이 불가능`하다.
- 한 번 발행한 `토큰`은 `유효기간이 끝나기 전까지 따로 통제할 수 없기 때문`에 세션에 비해 토큰 정보를 탈취 당할 가능성이 높다. 그러나 `토큰`은 `쿠키`처럼 `만료 기간`을 설정할 수 있어서 `만료 기간을 짧게 지정`해 피해를 줄일 수 있다.
- 즉, 토큰 방식은 `쿠키`와 `세션`을 적절히 섞은 것과 비슷하다고 할 수 있다.

### JWT(JSON Webb Token)

---

- JWT란, `인증에 필요한 정보들을 암호화시킨 JSON 토큰`을 의미한다.
- JWT 기반 인증은 `JWT 토큰(Access Token)`을 `HTTP 헤더`에 실어 `서버`가 `클라이언트`를 `식별`하는 방법이다.
- JWT는 JSON 데이터를 `Base64 URL-safe Encode`를 통해 인코딩하여 `직렬화`한 것이며, 토큰 내부에는 `위변조 방지`를 위해 `개인키를 통한 전자서명`도 들어있다. 따라서 사용자가 JWT를 서버로 전송하면 서버는 서명을 검증하는 과정을 거치게 되며 검증이 완료되면 요청한 응답을 돌려준다.
- JWT는 `Header`, `Payload`, `Signature` 3가지 구조가 존재한다.
    - Header에는 JWT에서 사용할 `타입`과 `해시 알고리즘의 종류`가 담긴다.
    - Payload에는 서버에서 첨부한 `사용자 권한 정보`와 `데이터`가 담겨 있다.
    - Signature에는 `Base64 URL-safe Encode`를 한 이후에 `Header에 명시된 해시함수를 적용`하고, `개인키(Private Key)`로 서명한 전자서명이 담겨 있다.
    
    ![image 3](https://github.com/user-attachments/assets/9c558680-211d-42fd-81b5-4cf2c38038c5)
    
- `Header`와 `Payload`는 `단순히 인코딩된 값`이기 때문에 `제 3자가 복호화 및 조작`할 수 있지만, `Signature`는 `서버` 측에서 관리하는 `비밀키가 유출되지 않는 이상 복호화할 수 없다.`
- 따라서 `Signature`는 `토큰의 위변조 여부를 확인`하는데 사용된다.

- **JWT를 이용한 인증 과정**
    
    ![image 4](https://github.com/user-attachments/assets/b6a07f29-f677-4918-92d7-8351268f3e85)
    
    1. 사용자가 ID, PW를 입력하여 서버에 로그인 인증을 요청한다.
    2. 서버에서 클라이언트로부터 인증 요청을 받으면, Header, PayLoad, Signature를 정의한다. Hedaer, PayLoad, Signature를 각각 Base64로 한 번 더 암호화하여 JWT를 생성하고 이를 쿠키에 담아 클라이언트에게 발급한다.
    3. 클라이언트는 서버로부터 받은 JWT를 로컬 스토리지에 저장한다. (쿠키나 다른 곳에 저장할 수도 있음)API를 서버에 요청할때 `Authorization header`에 `Access Token`을 담아서 보낸다.
    4. 서버가 할 일은 클라이언트가 Header에 담아서 보낸 JWT가 내 서버에서 발행한 토큰인지 일치 여부를 확인하여 일치한다면 인증을 통과시켜주고 아니라면 통과시키지 않으면 된다.
    5. 인증이 통과되었으므로 페이로드에 들어있는 유저의 정보들을 select해서 클라이언트에 돌려준다.
    6. 클라이언트가 서버에 요청을 했는데, 만일 액세스 토큰의 시간이 만료되면 클라이언트는 `리프래시 토큰`을 이용해서 서버로부터 `새로운 엑세스 토큰`을 발급 받는다.

- **토큰 인증 신뢰성을 가지는 경우**
    - 유저 JWT가 A(Header) + B(Payload) + C(Signature)일 때, 임의로 B를 수정하여 `B'`가 되었다.
    - 수정한 토큰(A + `B'` + C)을 서버에 요청 보내면 `유효성 검사`를 시행하여 대조 결과가 일치하지 않으면 `유저의 정보가 임의로 조작`되었다는 것을 알 수 있다.

- **JWT의 목적**
    - JWT는 Base64로 암호화를 하기 때문에 디버거를 사용해서 인코딩된 JWT를 1초만에 복호화할 수 있다.
    - 복호화를 하게 되면 `사용자의 데이터를 담은 Payload 부분이 그대로 노출`되어 버린다.
    - 따라서 `Payload`에는 `비밀번호와 같은 민감한 정보는 넣지 말아야 한다.`
    - 그럼 토큰 인증 방식 자체가 빛 좋은 개살구라고 생각할 수도 있지만, `토큰의 진짜 목적`은 `정보 보호`가 아닌, `위조 방지`이다.

- Access Token과 Refresh Token
    - JWT 역시 `제 3자에게 토큰 탈취의 위험`이 있기 때문에, 그대로 사용하는 것이 아닌 `Access Token`과 `Refresh Token`으로 `이중으로 나누어 인증`을 진행한다.
    - `Access Token`과 `Refresh Token`은 둘다 똑같은 JWT이다. 다만 `토큰이 어디에 저장되고 관리 되느냐에 따른 사용 차이`일 뿐이다.
    
    - **Access Token**
        - `클라이언트가 갖고 있는` 실제로 `유저의 정보가 담긴 토큰`으로, `클라이언트에서 요청이 오면 서버에서 해당 토큰에 있는 정보를 활용하여 사용자 정보에 맞게 응답`을 진행
    - **Refresh Token**
        - `새로운 Access Token을 발급해주기 위해 사용하는 토큰`으로, `짧은 수명을 가지는 Access Token에게 새로운 토큰을 발급해주기 위해` 사용
        - `해당 토큰`은 보통 `데이터베이스`에 `유저 정보와 같이 기록`
    
    정리하자면, Access Token은 접근에 관여하는 토큰, Refresh Token은 재발급에 관여하는 토큰의 역할로 사용되는 JWT 이라고 말할 수 있다.
    

- 서버에서 가장 피해야 할 것은 `데이터베이스 조회`이다. 서버 자체가 죽는 경우도 있지만, 대부분 DB가 터져서 서버도 같이 죽는 경우가 허다하기 때문이다.
- 이런 점에서, `JWT 토큰은 DB조회를 안해도 되는 장점`을 가지고 있다는 점이다. 만일 `payload`에 `유저 이름`과 `유저 등급`을 같이 두고 보내면, 서버에서는 유저 이름을 가지고 DB를 조회해서 유저 등급을 얻지 않아도 바로 원하는 정보를 취할 수 있다.

- **vs. Cookie & Session**
    
    ![image 5](https://github.com/user-attachments/assets/301f19d4-cfd7-4aff-b628-7c956d9e7eb7)
    

### 참고 자료

---

- [https://hongong.hanbit.co.kr/완벽-정리-쿠키-세션-토큰-캐시-그리고-cdn/](https://hongong.hanbit.co.kr/%EC%99%84%EB%B2%BD-%EC%A0%95%EB%A6%AC-%EC%BF%A0%ED%82%A4-%EC%84%B8%EC%85%98-%ED%86%A0%ED%81%B0-%EC%BA%90%EC%8B%9C-%EA%B7%B8%EB%A6%AC%EA%B3%A0-cdn/)
- [https://inpa.tistory.com/entry/WEB-📚-JWTjson-web-token-란-💯-정리](https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC)
