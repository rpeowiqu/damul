# 보안 공부

### 패킷

- 인터넷 : 패킷 교환 네트워크

- MTU : Maximum Transmission Unit 최대 전송 단위
  
  - Header + data
  
  - 기본값 1500Byte => 굉장히 작은 단위

- 우리가 보통 다루는 데이터는 조립된 데이터 => `Stream`

- Stream Data : File I/O (입출력)으로 다룸
  
  - File : 직렬적

### SSL : 보안 소켓 계층(Secure Sockets Layer)

- 주요 개념 :
  
  - Checksum, Hash
  
  - 대칭키, 비대칭키
  
  - PKI 시스템

- `PKI` : 공개키 기반구조(Public Key Infrastructure)
  
  - 인수분해의 어려움을 이용해 만듦

- 여기에 보안성이 포함되어야한다. -> 의도적인 재계산이 불가능해야한다.

- Checksum(검사합 : 중복 검사의 한 형태)은 사실상 보안성이 없다. -> 오류검출하는 데만 씀

- But Hash는 다르다.

### Hash (함수)의 특징

- 단방향성
  
  - f(x) -> y
  
  - y값 길이는 일정, 단방향성
  
  - y값으로 x값을 찾을 수 없음

- 입력 값의 크기와 상관 없이 **결과 값의 길이(혹은 크기)가 일정**

- 데이터 무결성 확보와 관련해 IT기술 전반에서 사용된다.

- 암호화는 아님. 그냥 결과를 구하는 것 뿐

### 대표적인 Hash 알고리즘

- **MD-5**
  
  - 패스워드 단방향 암호화에 사용금지됨. 
  
  - 해시 충돌 발생 : 전체 풀의 숫자가 작아서 다 깨졌다.
    
    - brute force attack으로 해시값 쉽게 역산 가능
  
  - 충돌이란?
    
    - A ≠ B, f(A) ≠ f(B)
    
    - 근데 B를 조작해서 f(B') = f(A)가 되면 안됨! (충돌)
    
    - 알고리즘 수준에서 해킹으로 간주 => 쓰면 안됨

- **SHA-1**
  
  - 얘도 뚫림
  
  - 이렇게 뚫린 애들은 Hashsum을 계산할 때 사용

- **SHA-128, 256, 384, 512**
  
  - 보통 SHA-256 많이 씀 -> 일상생활에서 가장 많이 볼 수 있음
  
  - 빡세게 가져가면 384도 가끔 씀
  
  - 얘네는 아무리 조작해도 같은 값이 나올 수 없다.

- `Hash` ≠ `Hashsum`

- 개인정보 보호법이 개정되면서 비밀번호는 평문으로 더이상 저장할 수 없고 Hash값으로 저장해야한다.

- **레인보우테이블 (rainbow table)** : 해시 함수를 사용하여 변환 가능한 모든 해시 값을 저장시켜 놓은 표

- **무작위 대입 공격(Brute Force Attack)** : 전체 경우의 수 노가다 대입 공격
  
  - 특수문자, 영어, 숫자 8자리 -> 8코어 : 1달 안 걸림, GPU : 몇 분 안 걸림, 양자컴퓨터 : 바로 나옴

- 좋은 Pwd? => 긴 거.... 긴 게 최고.

- SALT : 소금 => 요리에 간 하듯이. 현재 해시 전에 추가해서 사용한다.

### 대표적인 Hash 기술 활용예

- **무결성** 확보
  
  - 인증서 검증
  
  - 디지털 포렌식 : 디지털 증거를 수집하고 분석하는 과정 => 채증
    
    - ex) 디스크
  
  - **디지털 서명(Hash + PKI)**

- 패스워드 단방향 암호화

- **블록체인**

- 기타 등등 온갖 때에 다 쓰임

### 암호화

- 해시는 무결성을 확보하는 건데, 기밀 정보를 보관할때는?? -> 암호화

- 평문 -> 암호문 : 암호화 (보안성 부여)

- 평문 <- 암호문 : 복호화 (보안성 해제)

- 소지기반 : Key

### 대칭키(Symmetric key)

- 키 하나로 암호화/복호화를 모두 수행하는 방식

- 비대칭키 방식에 비해 효율적

- DES, 3DES, SEED-128, ARIA, AES-128, AES-256 알고리즘이 대표적

- 대칭키 작동원리
  
  - ex. `XOR`

- 여기서 `1101 0101`를 key라고 부름

- 키 길이가 짧은데도 보안성이 뛰어나서 cpu도 덜 사용한다.

- 네트워크에서 사용 단점 : **구조적 한계**
  
  - 상대 컴퓨터에게 key를 안전하게 전달하기 어려움

- 그래서 탄생한 비대칭키!

### 비대칭키(Asymmetric key)

- 한 쌍의 키가 서로 상호작용하는 구조

- **두 키 중 하나로 암호화 하면 쌍을 이루는 다른 키로 복호화**

- 보통 **Public key(공개키)와 Private key(비공개키)** 로 구분하며 PKI(Public Key Instructrue) 기술의 근간을 이룸
  
  - 공개키는 인터넷에 공개

- RSA-2048, ECC 알고리즘이 대표적
  
  - 2048이면 cpu를 엄청 많이 사용한다.
  
  - 효율은 대칭키가 압도적으로 좋다.

### 디지털 서명이란?

- **Priate key로 해시 결과를 암호화하는 것이다!**

- 읽기 가능한 정보(ex. 계약서)가 있다. -> 누구라도 쉽게 수정 -> 정보 변조

- 이렇게 위조된 걸 hash값으로 알 수 있음
  
  - 서버가 공개해놓은 해시값과, 받은 문서를 public key로 구한 해시값을 비교해서 문서 위조 판단 가능

- private key를 저장 -> 소지 기반
  
  - ex. usb, 드라이버 등에 저장 => 인증서

- 1단계 : 키 쌍 생성
  
  - RSA-2048 하자 (약속)
  
  - 서로 키 쌍 생성

- 2단계 : 키 교환
  
  - 각자가 생성한 public key를 상대방에게 줌 (인터넷 노출)
  
  - 보안성을 부여하는데 사용하기 때문에 괜찮음

- 3단계 : 상대방의 public key로 암호화해서 보내주면 자신의 private key로 복호화 가능

- => Tnnul : 터널링 (비밀통신)

- 문제점 :
  
  - 성능 이슈 조금 있음 => 키 쌍 생성
    
    +랜덤으로 키 쌍을 골라야 하는데, 이 랜덤 생성이 어렵다.
  
  - 키 쌍 하나 생성하는 데 1~2초 걸림 => 서버는 클라이언트마다 생성해야 해서 무리
  
  - 매번 새로 생성하기엔 너무 힘듦 => **재사용**하자. -> 서버는 그냥 계속 쓰거나 1시간 간격으로 바꿈
  
  - 슈퍼컴퓨터가 계산해도 10년 걸리니깐 괜찮다.

### 대칭 키와 비대칭 키 혼합 사용으로 효율 극대화

1. 서버는 키를 미리 생성

2. pc는 부팅되자마자 키 생성

3. pc는 서버가 준 public key로 자신의 대칭 key를 암호화해서 보내버림

4. 서버가 대칭 key를 자신의 private key로 복호화하여 대칭 key 사용
- 서버는 클라이언트마다 키가 다름 => 보안이 더 뛰어남

- 이때 쓰는 대칭 key를 **세션키**라고도 부른다!
