### VAC 패턴

---

- HTML과 거의 유사한 `뷰(View) 컴포넌트`와 `비즈니스 로직(Business Logic)만을 담고 있는 컴포넌트`를 만드는 것으로 `역할을 완전히 분리하는 패턴`
    - **뷰(View)**
        - `데이터`를 `표시`하는 것으로, 화면에 나타나는 부분(UI)이다.
    - **비즈니스 로직(Business Logic)**
        - 컴퓨터 프로그램에서 실세계의 규칙에 따라 `데이터`를 생성, 표시 저장, 변경하는 부분을 일컫는다.

- VAC 패턴은 React에서 상태 관리를 체계적으로 처리하기 위해 자주 사용되는 패턴 중 하나로,  V(View), A(Action), C(Control)의 약자를 따왔다.
- 즉, `모든 컴포넌트`를 `뷰 파일`과 `로직 파일`로 `분리`하여 유지보수가 편리하다. 디자인이 변경될 경우 View 컴포넌트만 확인하면 되고, 비즈니스 로직이 변경될 경우 비즈니스 컴포넌트 영역만 수정하면 되기 때문이다.
    
    ![Image](https://github.com/user-attachments/assets/0e588c0b-3179-4490-84ac-d5ec0307d51b)
    

- **장점**
    1. **역할 분리로 인한 코드 가독성 증가**
    View, Action, Control 각각이 자신의 역할에 충실하도록 코드를 나누므로, 각 부분의 책임이 명확해집니다.
    코드를 읽는 사람이 로직과 UI를 구분하기 쉬워 유지보수성이 높아집니다.
    2. **테스트 용이성**
    **View:** UI 렌더링에 관한 테스트만 작성하면 되므로 단순합니다.
    Action과 Control: 비즈니스 로직과 상태 관리를 독립적으로 테스트할 수 있습니다.
    이는 특히 대규모 애플리케이션에서 신뢰성을 높이는 데 유리합니다.
    3. **재사용성 증가**
    View는 상태와 독립적이므로 여러 컨텍스트에서 재사용할 수 있습니다.
    Control 또는 Action에서 정의된 상태 관리 로직을 다른 View와 조합하여 사용할 수 있습니다.
    4. **단방향 데이터 흐름 강화**
    React의 단방향 데이터 흐름 철학과 잘 맞아떨어집니다.
    상태가 Control에서만 관리되므로, 데이터의 흐름과 상태 변경 과정을 추적하기 쉽습니다.
    5. **유지보수성 향상**
    요구사항이 변경되거나 기능이 확장되어도 View와 상태 관리 로직이 분리되어 있어, 한쪽의 변경이 다른 쪽에 미치는 영향을 최소화할 수 있습니다.
    6. **협업 효율성 향상**
    View 개발자와 비즈니스 로직 개발자가 역할을 분담할 수 있어 협업 효율성이 높아집니다.
    특히 팀 규모가 클수록 VAC 패턴은 더 유리합니다.

- **단점**
    1. **복잡성 증가**
    간단한 애플리케이션에서는 역할 분리가 오히려 불필요한 복잡성을 초래할 수 있습니다.
    작은 컴포넌트에서 VAC 패턴을 과도하게 적용하면 코드가 과도하게 나뉘어 읽기 어렵게 느껴질 수 있습니다.
    2. **오버엔지니어링의 위험**
    간단한 로직을 불필요하게 세분화하면 생산성과 유지보수성에 부정적인 영향을 줄 수 있습니다.
    예를 들어, 카운터 컴포넌트처럼 단순한 상태 관리가 필요한 경우 VAC 패턴은 과도한 접근이 될 수 있습니다.
    3. **초기 구현 비용**
    프로젝트의 초기 설계 단계에서 VAC 패턴을 제대로 설정하는 데 더 많은 시간이 필요합니다.
    특히 대규모 프로젝트에서 각 역할의 명확한 정의와 일관된 적용이 요구됩니다.
    4. **추가적인 데이터 전달 코드**
    상태와 UI가 분리되면서 Props나 Context를 통해 데이터를 전달하는 코드가 늘어날 수 있습니다.
    이는 데이터 흐름이 복잡한 경우 관리 포인트를 늘리고, 오히려 디버깅을 어렵게 만들 가능성이 있습니다.
    5. **Context Switching 증가**
    역할이 분리되면서 서로 다른 파일(예: View, Action, Control)로 나뉘게 되면, 파일 간 이동이 잦아지고 작업 흐름이 분산될 수 있습니다.

- **샘플 코드**
    
    ```jsx
    // View 컴포넌트
    const CounterView = ({ count, onIncrement }) => (
      <div>
        <p>현재 카운트: {count}</p>
        <button onClick={onIncrement}>증가</button>
      </div>
    );
    ```
    
    ```jsx
    // Action + Control 컴포넌트
    const CounterAction = ({ count, setCount }) => {
    	const [count, setCount] = useState(0);
    
      const handleIncrement = () => {
        // Control에 상태 변경 요청
        setCount(count + 1);
      };
    
      return <CounterView count={count} onIncrement={handleIncrement} />;
    };
    ```
